#include <iostream>
#include <ctime>
#include <string>
#include <fstream>

//ИМЯ ФУНКЦИИ ДОЛЖНО СОТВЕТСТВОВАТЬ КОНКРЕТНОЙ ВАРИАЦИИ ИЗ ФАЙЛА
// Для шифра Ш1.1.1 - v1_1_1

int v1_1_1(ifstream* input_file, ofstream* output_file, offsets offset) {
    // Логика сдвига
    offset.lat = 3; offset.kir = 5; offset.num = 2;

    // Вызов основной функции (шифр Цезаря)
    return caesar(input_file, output_file, offset);
}

int v1_1_2(ifstream* input_file, ofstream* output_file, offsets offset) {
    // Логика сдвига
    offset.lat = -3; offset.kir = -5; offset.num = -2;

    // Вызов основной функции (шифр Цезаря)
    return caesar(input_file, output_file, offset);
}

// Ш1.2.1 - однонаправленный сдвиг вправо, зависящий от времени начала шифрования
int v1_2_1(ifstream* input_file, ofstream* output_file, offsets offset) {
    int minute = get_minute();
    if (minute % 2 == 0) { // Четная минута
        offset.lat = 3;
        offset.kir = 5;
        offset.num = 3;
    } else { // Нечетная минута
        offset.lat = 4;
        offset.kir = 6;
        offset.num = 2;
    }
    return caesar(input_file, output_file, offset);
}

// Ш1.2.2 - однонаправленный сдвиг влево, зависящий от времени начала шифрования
int v1_2_2(ifstream* input_file, ofstream* output_file, offsets offset) {
    int minute = get_minute();
    if (minute % 2 == 0) {
        offset.lat = -3;
        offset.kir = -5;
        offset.num = -3;
    } else {
        offset.lat = -4;
        offset.kir = -6;
        offset.num = -2;
    }
    return caesar(input_file, output_file, offset);
}

// Ш1.2.3 - одинаковый разнонаправленный сдвиг, зависящий от времени начала шифрования
int v1_2_3(ifstream* input_file, ofstream* output_file, offsets offset) {
    int minute = get_minute();
    if (minute % 2 == 0) { // Четная минута - сдвиг вправо
        offset.lat = 3;
        offset.kir = 5;
        offset.num = 3;
    } else { // Нечетная минута - сдвиг влево
        offset.lat = -3;
        offset.kir = -5;
        offset.num = -3;
    }
    return caesar(input_file, output_file, offset);
}

// Ш1.2.4 - разнонаправленные сдвиги, зависящие от времени начала шифрования
int v1_2_4(ifstream* input_file, ofstream* output_file, offsets offset) {
    int minute = get_minute();
    if (minute % 2 == 0) { // Четная минута - - сдвиг вправо
        offset.lat = 3;
        offset.kir = 5;
        offset.num = 3;
    } else { // Нечетная минута - - сдвиг влево
        offset.lat = -4;
        offset.kir = -6;
        offset.num = -2;
    }
    return caesar(input_file, output_file, offset);
}

// Ш1.2.5: Ш1.2.1 с учётом четности дня месяца (вправо)
int v1_2_5(ifstream* input_file, ofstream* output_file, offsets offset) {
    int day_of_month = get_mouth_day();
    if (day_of_month % 2 == 0) { // Четный день месяца
        offset.lat = 3;
        offset.kir = 5;
        offset.num = 3;
    } else { // Нечетный день месяца
        offset.lat = 4;
        offset.kir = 6;
        offset.num = 2;
    }
    return caesar(input_file, output_file, offset);
}

// Ш1.2.6: Ш1.2.2 с учётом четности дня месяца (влево)
int v1_2_6(ifstream* input_file, ofstream* output_file, offsets offset) {
    int day_of_month = get_mouth_day();
    if (day_of_month % 2 == 0) { // Четный день месяца
        offset.lat = -3;
        offset.kir = -5;
        offset.num = -3;
    } else { // Нечетный день месяца
        offset.lat = -4;
        offset.kir = -6;
        offset.num = -2;
    }
    return caesar(input_file, output_file, offset);
}

// Ш1.2.7: Ш1.2.3 с одинаковыми разнонаправленными сдвигами, зависящими от числа месяца
int v1_2_7(ifstream* input_file, ofstream* output_file, offsets offset) {
    int day_of_month = get_mouth_day();

    if (day_of_month % 2 == 0) { // Четный день месяца - сдвиг вправо
        offset.lat = 3;
        offset.kir = 5;
        offset.num = 3;
    } else { // Нечетный день месяца - сдвиг влево
        offset.lat = -3;
        offset.kir = -5;
        offset.num = -3;
    }

    return caesar(input_file, output_file, offset);
}

// Ш1.2.8: Ш1.2.4 с разными разнонаправленными сдвигами, зависящими от числа месяца
int v1_2_8(ifstream* input_file, ofstream* output_file, offsets offset) {
    int day_of_month = get_mouth_day();
    if (day_of_month % 2 == 0) { // Четный день месяца - сдвиг вправо
        offset.lat = 3;
        offset.kir = 5;
        offset.num = 3;
    } else { // Нечетный день месяца - сдвиг влево
        offset.lat = -4;
        offset.kir = -6;
        offset.num = -2;
    }
    return caesar(input_file, output_file, offset);
}

// Ш1.2.9: Ш1.2.1 с учётом четности дня недели (вправо)
int v1_2_9(ifstream* input_file, ofstream* output_file, offsets offset) {
    int week_day = get_week_day();
    if (week_day % 2 == 0) { // Четный день недели
        offset.lat = 3;
        offset.kir = 5;
        offset.num = 3;
    } else { // Нечетный день недели
        offset.lat = 4;
        offset.kir = 6;
        offset.num = 2;
    }
    return caesar(input_file, output_file, offset);
}

// Ш1.2.10: Ш1.2.2 с учётом четности дня недели (влево)
int v1_2_10(ifstream* input_file, ofstream* output_file, offsets offset) {
    int week_day = get_week_day();
    if (week_day % 2 == 0) { // Четный день недели
        offset.lat = -3;
        offset.kir = -5;
        offset.num = -3;
    } else { // Нечетный день недели
        offset.lat = -4;
        offset.kir = -6;
        offset.num = -2;
    }
    return caesar(input_file, output_file, offset);
}

// Ш1.2.11: Ш1.2.3 с одинаковыми разнонаправленными сдвигами, зависящими от дня недели
int v1_2_11(ifstream* input_file, ofstream* output_file, offsets offset) {
    int week_day = get_week_day();
    if (week_day % 2 == 0) { // Четный день недели - сдвиг вправо
        offset.lat = 3;
        offset.kir = 5;
        offset.num = 3;
    } else { // Нечетный день недели - сдвиг влево
        offset.lat = -3;
        offset.kir = -5;
        offset.num = -3;
    }
    return caesar(input_file, output_file, offset);
}

// Ш1.2.12: Ш1.2.4 с разными разнонаправленными сдвигами, зависящими от дня недели
int v1_2_12(ifstream* input_file, ofstream* output_file, offsets offset) {
    int week_day = get_week_day();
    if (week_day % 2 == 0) { // Четный день недели - сдвиг вправо
        offset.lat = 3;
        offset.kir = 5;
        offset.num = 3;
    } else { // Нечетный день недели - сдвиг влево
        offset.lat = -4;
        offset.kir = -6;
        offset.num = -2;
    }
    return caesar(input_file, output_file, offset);
}
/*
int time_based_decorator(ifstream* input_file, ofstream* output_file, offsets offset) {
    int week_day = get_week_day();  // Получаем текущий день недели
    int minute = get_minute();      // Получаем текущую минуту
    int day_of_month = get_mouth_day();  // Получаем текущий день месяца

    if (minute%2 == 0)
    {
        offset.lat += 3;
        offset.kir += 5;
        offset.num += 3;
        cout << "День недели: " << week_day << ", Сдвиг по латинице вправо на " << 3 << endl;
        cout << "Минуты: " << minute << ", Сдвиг для кириллицы вправо на " << 5 << endl;
        cout << "День месяца: " << day_of_month << ", Сдвиг для чисел вправо на " << 3 << endl;
    }
    else
    {
        offset.lat += 4;
        offset.kir += 6;
        offset.num += 2;
        cout << "День недели: " << week_day << ", Сдвиг по латинице вправо на " << 4 << endl;
        cout << "Минуты: " << minute << ", Сдвиг для кириллицы вправо на " << 6 << endl;
        cout << "День месяца: " << day_of_month << ", Сдвиг для чисел вправо на " << 2 << endl;
    }

    // Вызов основной функции (шифр Цезаря)
    return caesar(input_file, output_file, offset);
}
*/
//
int v1_3_1(ifstream* input_file, ofstream* output_file, offsets offset) {
    // Логика сдвига
    offset.lat = 3; offset.kir = 5; offset.num = 2; offset.symbol_count_needed = true;

    // Вызов основной функции (шифр Цезаря)
    return caesar(input_file, output_file, offset);
}
int v1_3_2(ifstream* input_file, ofstream* output_file, offsets offset) {
    // Логика сдвига
    offset.lat = -3; offset.kir = -5; offset.num = -2; offset.symbol_count_needed = true;

    // Вызов основной функции (шифр Цезаря)
    return caesar(input_file, output_file, offset);
}
